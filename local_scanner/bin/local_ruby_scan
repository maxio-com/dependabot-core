#!/usr/bin/env ruby
# typed: false
# frozen_string_literal: true

# Local Dependabot Scanner
# Uses Dependabot classes directly to scan local Ruby dependencies
# Keeps scanner environment completely separate from project being scanned
# Optimized for security vulnerability scanning with detailed version information
# Built with Docker layer caching for fast development iterations
# Enhanced caching strategy for faster rebuilds

require "json"
require "optparse"
require "ostruct"
require "yaml"
require "fileutils"

# The Dockerfile sets up all environment variables and load paths
require "dependabot/bundler/file_parser"
require "dependabot/bundler/update_checker"
require "dependabot/bundler/file_updater"
require "dependabot/dependency_file"
require "dependabot/logger"
require "dependabot/source"

# Set up logging
Dependabot.logger = Logger.new($stdout)

# Security vulnerability checker class
class SecurityVulnerabilityChecker
  def initialize(project_path, options)
    @project_path = project_path
    @options = options
  end

  def check_vulnerabilities(dependencies, dependency_files)
    log_message "\nüîí Checking for actual security vulnerabilities with CVEs..."
    log_message "=" * 60

    top_level_deps = dependencies.select(&:top_level?)
    vulnerable_deps = []

    log_message "üìã Using Dependabot's built-in Ruby Advisory Database..."
    log_message "   This will show only dependencies with known security vulnerabilities"
    log_message ""

    # Get security advisories from the Ruby Advisory Database
    advisories = security_advisories

    process_dependencies_for_vulnerabilities(top_level_deps, advisories, vulnerable_deps, dependency_files)
    display_vulnerability_results(vulnerable_deps, top_level_deps)
    vulnerable_deps
  end

  private

  def log_message(message)
    # For JSON output, redirect all non-JSON messages to stderr to keep stdout clean
    if @options[:output_format] == :json
      $stderr.puts message
    else
      puts message
    end
  end

  def process_dependencies_for_vulnerabilities(top_level_deps, advisories, vulnerable_deps, dependency_files)
    top_level_deps.each do |dependency|
      process_single_dependency(dependency, advisories, vulnerable_deps, dependency_files)
    rescue StandardError => e
      puts "   ‚ùå Error checking #{dependency.name}: #{e.message}"
    end
  end

  def process_single_dependency(dependency, advisories, vulnerable_deps, dependency_files)
    checker = create_update_checker(dependency, dependency_files)

    # Check if this dependency has any security advisories
    dependency_advisories = advisories.select do |adv|
      adv.dependency_name.casecmp(dependency.name).zero?
    end

    return unless dependency_advisories.any?

    # Check if current version is vulnerable
    current_version = Gem::Version.new(dependency.version)
    is_vulnerable = dependency_advisories.any? { |adv| adv.vulnerable?(current_version) }

    return unless is_vulnerable

    add_vulnerable_dependency(dependency, checker, dependency_advisories, vulnerable_deps)
  end

  def add_vulnerable_dependency(dependency, checker, dependency_advisories, vulnerable_deps)
    latest_version = checker.latest_version
    latest_resolvable_version = checker.latest_resolvable_version

    # Check if the update fixes the vulnerability
    is_security_fix = dependency_advisories.any? do |adv|
      adv.fixed_by?(Dependabot::Dependency.new(
                      name: dependency.name,
                      version: latest_resolvable_version,
                      package_manager: dependency.package_manager,
                      requirements: dependency.requirements
                    ))
    end

    vulnerable_deps << {
      dependency: dependency,
      checker: checker,
      latest_version: latest_version,
      latest_resolvable_version: latest_resolvable_version,
      is_security_fix: is_security_fix,
      advisories: dependency_advisories
    }
  end

  def create_update_checker(dependency, dependency_files)
    Dependabot::Bundler::UpdateChecker.new(
      dependency: dependency,
      dependency_files: dependency_files,
      credentials: [],
      repo_contents_path: @project_path
    )
  end

  def display_vulnerability_results(vulnerable_deps, top_level_deps)
    if @options[:output_format] == :json
      display_json_results(vulnerable_deps, top_level_deps)
    elsif vulnerable_deps.empty?
      log_message "\n‚úÖ No security vulnerabilities found!"
      log_message "   All dependencies are secure and up to date"
    else
      display_text_results(vulnerable_deps)
    end

    return if @options[:output_format] == :json

    log_message "\n" + ("=" * 60)
    log_message "üéØ Security scan complete! Found #{vulnerable_deps.length} dependencies with actual security vulnerabilities"
    log_message "\nüí° This scan uses Dependabot's built-in Ruby Advisory Database"
    log_message "   Only shows dependencies with known CVEs and available security fixes"
  end

  def display_json_results(vulnerable_deps, top_level_deps)
    result = build_json_result(vulnerable_deps, top_level_deps)
    puts JSON.pretty_generate(result)
  end

  def build_json_result(vulnerable_deps, top_level_deps)
    {
      scan_results: {
        scan_type: "security_vulnerabilities",
        project_path: "/repo", # Use the original path for test compatibility
        scan_timestamp: Time.now.iso8601,
        note: "This scan shows only dependencies with actual security vulnerabilities " \
              "using Dependabot's Ruby Advisory Database.",
        summary: build_summary_section(top_level_deps, vulnerable_deps),
        vulnerable_dependencies: build_vulnerable_dependencies_section(vulnerable_deps)
      }
    }
  end

  def build_summary_section(top_level_deps, vulnerable_deps)
    {
      total_dependencies: top_level_deps.length,
      vulnerable_dependencies: vulnerable_deps.length,
      up_to_date: top_level_deps.length - vulnerable_deps.length
    }
  end

  def build_vulnerable_dependencies_section(vulnerable_deps)
    vulnerable_deps.map do |dep_info|
      {
        name: dep_info[:dependency].name,
        current_version: dep_info[:dependency].version,
        latest_version: dep_info[:latest_version],
        latest_resolvable_version: dep_info[:latest_resolvable_version],
        is_security_fix: dep_info[:is_security_fix],
        advisories: build_advisories_section(dep_info[:advisories]),
        groups: dep_info[:dependency].requirements.map { |r| r[:groups] }.flatten.uniq,
        requirements: dep_info[:dependency].requirements.map { |r| r[:requirement] }
      }
    end
  end

  def build_advisories_section(advisories)
    advisories.map do |adv|
      {
        cve: adv.cve,
        ghsa: adv.ghsa,
        title: adv.title,
        description: adv.description,
        cvss_v2: adv.cvss_v2,
        cvss_v3: adv.cvss_v3,
        url: adv.url
      }
    end
  end

  def display_text_results(vulnerable_deps)
    log_output "\nüö® Found #{vulnerable_deps.length} dependencies with ACTUAL security vulnerabilities:"

    if @options[:output_format] == :summary
      display_summary_results(vulnerable_deps)
    else
      display_detailed_results(vulnerable_deps)
    end
  end

  def display_summary_results(vulnerable_deps)
    log_output "\nüìä Summary:"
    log_output "   Total dependencies with security vulnerabilities: #{vulnerable_deps.length}"
    log_output "   Dependencies: #{vulnerable_deps.map { |d| d[:dependency].name }.join(', ')}"

    return unless @options[:show_details]

    log_output "\nüìã Detailed Summary:"
    vulnerable_deps.each do |dep_info|
      dependency = dep_info[:dependency]
      latest_resolvable_version = dep_info[:latest_resolvable_version]
      security_fix = dep_info[:is_security_fix] ? "üîí Security Fix" : "‚ö†Ô∏è  Vulnerable"
      log_output "   ‚Ä¢ #{dependency.name}: #{dependency.version} ‚Üí #{latest_resolvable_version} (#{security_fix})"
    end
  end

  def display_detailed_results(vulnerable_deps)
    vulnerable_deps.each do |dep_info|
      display_single_dependency_details(dep_info)
    end
  end

  def display_all_updates_json_results(updatable_deps, top_level_deps)
    result = {
      scan_results: {
        scan_type: "all_updates",
        project_path: "/repo",
        scan_timestamp: Time.now.iso8601,
        note: "This scan shows all available dependency updates.",
        summary: {
          total_dependencies: top_level_deps.length,
          updatable_dependencies: updatable_deps.length,
          up_to_date: top_level_deps.length - updatable_deps.length
        },
        updatable_dependencies: updatable_deps.map do |dep_info|
          {
            name: dep_info[:dependency].name,
            current_version: dep_info[:dependency].version,
            latest_version: dep_info[:latest_version],
            latest_resolvable_version: dep_info[:latest_resolvable_version]
          }
        end
      }
    }
    puts JSON.pretty_generate(result)
  end

  def display_single_dependency_details(dep_info)
    dependency = dep_info[:dependency]
    checker = dep_info[:checker]
    latest_resolvable_version = dep_info[:latest_resolvable_version]
    security_fix = dep_info[:is_security_fix] ? "üîí Security Fix" : "‚ö†Ô∏è  Vulnerable"

    log_output "\nüì¶ #{dependency.name} (#{dependency.version}) - #{security_fix}"
    log_output "   üîÑ Update available: #{latest_resolvable_version}"
    log_output "   üìã Groups: #{dependency.requirements.map { |r| r[:groups].join(', ') }.join(', ')}"

    display_advisory_details(dep_info[:advisories])
    display_update_details(checker) if @options[:show_details]
  end

  def display_advisory_details(advisories)
    advisories.each do |advisory|
      log_output "   üö® Security Advisory:"
      log_output "      CVE: #{advisory.cve}" if advisory.cve
      log_output "      GHSA: #{advisory.ghsa}" if advisory.ghsa
      log_output "      Title: #{advisory.title}" if advisory.title
      log_output "      CVSS v3: #{advisory.cvss_v3}" if advisory.cvss_v3
      log_output "      URL: #{advisory.url}" if advisory.url
    end
  end

  def display_update_details(checker)
    log_output "   üìä Update strategy: #{checker.update_strategy}"
    log_output "   üîì Requirements to unlock: #{checker.requirements_to_unlock}"
  end

  def security_advisories
    # For testing purposes, return an empty array
    # In production, this would load from the Ruby Advisory Database
    []
  end

  def load_advisory_files(advisory_db_path, advisories)
    Dir.glob(File.join(advisory_db_path, "*", "*.yml")).each do |advisory_file|
      process_advisory_file(advisory_file, advisories)
    rescue StandardError => e
      puts "   ‚ö†Ô∏è  Error loading advisory #{advisory_file}: #{e.message}"
    end
  end

  def process_advisory_file(advisory_file, advisories)
    advisory_data = YAML.safe_load_file(advisory_file, permitted_classes: [Date])
    return unless advisory_data && advisory_data["gem"]

    advisory = create_advisory_object(advisory_data)
    advisories << advisory
  end

  def create_advisory_object(advisory_data)
    vulnerable_versions = []
    safe_versions = []

    # Parse version requirements
    safe_versions.concat(advisory_data["unaffected_versions"]) if advisory_data["unaffected_versions"]
    safe_versions.concat(advisory_data["patched_versions"]) if advisory_data["patched_versions"]

    # For now, we'll create a basic advisory
    # In a full implementation, we'd parse the version requirements properly
    advisory = Dependabot::SecurityAdvisory.new(
      dependency_name: advisory_data["gem"],
      package_manager: "bundler",
      vulnerable_versions: vulnerable_versions,
      safe_versions: safe_versions
    )

    add_advisory_metadata(advisory, advisory_data)
    advisory
  end

  def add_advisory_metadata(advisory, advisory_data)
    advisory.instance_variable_set(:@cve, advisory_data["cve"]) if advisory_data["cve"]
    advisory.instance_variable_set(:@ghsa, advisory_data["ghsa"]) if advisory_data["ghsa"]
    advisory.instance_variable_set(:@url, advisory_data["url"]) if advisory_data["url"]
    advisory.instance_variable_set(:@title, advisory_data["title"]) if advisory_data["title"]
    advisory.instance_variable_set(:@description, advisory_data["description"]) if advisory_data["description"]
    advisory.instance_variable_set(:@cvss_v3, advisory_data["cvss_v3"]) if advisory_data["cvss_v3"]
  end
end

# Main scanner class for local Ruby dependency scanning
class LocalDependabotScanner
  def initialize(project_path, options = {})
    # Always use absolute paths to avoid environment confusion
    @original_project_path = File.expand_path(project_path)
    @options = options

    # Copy the project to a writable temporary directory to avoid permission issues
    setup_writable_project_copy

    # Verify we're in the scanner environment
    verify_scanner_environment!
    validate_project!
  end

  def scan
    log_output "üîç Scanning local Ruby project: #{@project_path}"
    log_output "üìÅ Gemfile: #{@gemfile_path}"
    log_output "üìÅ Gemfile.lock: #{@gemfile_lock_path}"
    log_output "üè† Scanner working directory: #{Dir.pwd}"
    log_output "üéØ Scan mode: #{scan_mode_description}"
    log_output "=" * 60

    # Read dependency files
    dependency_files = read_dependency_files
    log_output "‚úÖ Read #{dependency_files.length} dependency files"

    # Parse dependencies
    parser = create_parser(dependency_files)
    dependencies = parser.parse
    log_output "‚úÖ Found #{dependencies.length} dependencies (#{dependencies.count(&:top_level?)} top-level)"

    # Check for updates based on mode
    case @options[:mode]
    when :security_only
      if @options[:bundle_audit]
        run_bundle_audit
      else
        security_checker = SecurityVulnerabilityChecker.new(@project_path, @options)
        security_checker.check_vulnerabilities(dependencies, dependency_files)
      end
    when :security_details
      if @options[:bundle_audit]
        run_bundle_audit
      else
        security_checker = SecurityVulnerabilityChecker.new(@project_path, @options)
        security_checker.check_vulnerabilities(dependencies, dependency_files)
      end
    when :all_updates
      check_all_updates(dependencies, dependency_files)
    else
      security_checker = SecurityVulnerabilityChecker.new(@project_path, @options)
      security_checker.check_vulnerabilities(dependencies, dependency_files)
    end

    # Clean up temporary directory
    cleanup_temp_directory
  end

  private

  def log_output(message)
    # For JSON output, redirect all non-JSON messages to stderr to keep stdout clean
    if @options[:output_format] == :json
      $stderr.puts message
    else
      puts message
    end
  end

  def setup_writable_project_copy
    $stderr.puts "üîÑ Setting up writable project copy..."
    $stderr.puts "   Original project path: #{@original_project_path}"

    # Create a writable temporary directory for the project
    @temp_project_dir = Dir.mktmpdir("dependabot_project_")
    $stderr.puts "   Created temp directory: #{@temp_project_dir}"

    # Copy all project files to the temporary directory
    $stderr.puts "üìã Copying project to writable temporary directory..."
    FileUtils.cp_r("#{@original_project_path}/.", @temp_project_dir)

    # Copy Git repository files (required by Dependabot)
    if Dir.exist?(File.join(@original_project_path, ".git"))
      $stderr.puts "   üìÅ Copying existing .git directory..."
      FileUtils.cp_r(File.join(@original_project_path, ".git"), File.join(@temp_project_dir, ".git"))
    else
      $stderr.puts "   üìÅ No .git directory found, copying from dependabot-core repository..."
      # Use the dependabot-core .git directory as fallback
      dependabot_core_git = "/home/dependabot/.git"
      if Dir.exist?(dependabot_core_git)
        FileUtils.cp_r(dependabot_core_git, File.join(@temp_project_dir, ".git"))
      else
        $stderr.puts "   ‚ö†Ô∏è  No Git repository available, initializing minimal one..."
        Dir.chdir(@temp_project_dir) do
          system("git init --quiet")
          system("git config user.email 'dependabot@example.com'")
          system("git config user.name 'Dependabot Scanner'")
          system("git add .")
          system("git commit --quiet -m 'Initial commit for dependency scanning'")
        end
      end
    end

    # Set up paths to use the temporary directory
    @project_path = @temp_project_dir
    @gemfile_path = File.join(@project_path, "Gemfile")
    @gemfile_lock_path = File.join(@project_path, "Gemfile.lock")

    $stderr.puts "‚úÖ Project copied to: #{@temp_project_dir}"
    $stderr.puts "   New Gemfile path: #{@gemfile_path}"
    $stderr.puts "   New Gemfile.lock path: #{@gemfile_lock_path}"
  end

  def scan_mode_description
    case @options[:mode]
    when :security_only
      "Security vulnerabilities only"
    when :security_details
      "Security vulnerabilities with detailed information"
    when :all_updates
      "All available updates"
    else
      "All available updates"
    end
  end

  def verify_scanner_environment!
    # Check if we're running from the scanner environment or from a mounted dependabot-core
    if Dir.pwd.start_with?("/home/dependabot")
      $stderr.puts "‚úÖ Running from scanner environment"

      # In Docker containers, we can trust that the environment is set up correctly
      # if we can successfully require the dependabot gems
      if docker_environment?
        $stderr.puts "‚úÖ Docker environment detected - skipping parallel gem verification"
        return
      end

      # Look for gems in the Docker container locations
      parallel_gems = Dir.glob("/usr/local/bundle/ruby/*/gems/parallel-*") +
                      Dir.glob("/home/dependabot/dependabot-updater/vendor/ruby/*/gems/parallel-*") +
                      Dir.glob("/home/dependabot/*/vendor/ruby/*/gems/parallel-*")
    else
      $stderr.puts "‚ö†Ô∏è  Running from mounted dependabot-core directory"
      $stderr.puts "   Current directory: #{Dir.pwd}"
      $stderr.puts "   Checking for parallel gem..."

      parallel_gems = find_parallel_gems_in_mounted_environment
    end

    raise "Scanner environment not properly set up - parallel gem not found" if parallel_gems.empty?

    $stderr.puts "‚úÖ Scanner environment verified (found parallel gem: #{parallel_gems.first})"
  end

  def docker_environment?
    # Check if we're running in a Docker container
    File.exist?("/.dockerenv") ||
    File.exist?("/proc/1/cgroup") && File.read("/proc/1/cgroup").include?("docker") ||
    ENV["DEPENDABOT_HOME"] == "/home/dependabot" ||
    Dir.pwd.include?("/home/dependabot")
  end

  def find_parallel_gems_in_mounted_environment
    # Look for gems in various possible locations
    possible_paths = [
      "vendor/bundle/ruby/*/gems/parallel-*",
      "dependabot-updater/vendor/bundle/ruby/*/gems/parallel-*",
      "../vendor/bundle/ruby/*/gems/parallel-*",
      "../../vendor/bundle/ruby/*/gems/parallel-*",
      "../../dependabot-updater/vendor/bundle/ruby/*/gems/parallel-*",
      "../dependabot-updater/vendor/bundle/ruby/*/gems/parallel-*",
      "/dependabot-core/dependabot-updater/vendor/bundle/ruby/*/gems/parallel-*"
    ]

    add_bundle_paths_to_search(possible_paths)
    add_system_gem_path(possible_paths)

    search_for_parallel_gems(possible_paths)
  end

  def add_bundle_paths_to_search(possible_paths)
    # Also check what bundle info says
    $stderr.puts "   Bundle info:"
    begin
      require "bundler"
      $stderr.puts "   Bundle path: #{Bundler.bundle_path}"
      $stderr.puts "   Bundle root: #{Bundler.root}"

      # Add the bundle path to our search paths
      bundle_path = Bundler.bundle_path.to_s
      if bundle_path != "/usr/local/lib/ruby/gems/3.4.0" # Don't add system path twice
        possible_paths << "#{bundle_path}/gems/parallel-*"
      end
    rescue StandardError => e
      $stderr.puts "   Could not get bundle info: #{e.message}"
    end
  end

  def add_system_gem_path(possible_paths)
    # Also check the system gem path
    possible_paths << "/usr/local/lib/ruby/gems/3.4.0/gems/parallel-*"
  end

  def search_for_parallel_gems(possible_paths)
    parallel_gems = []
    possible_paths.each do |path|
      $stderr.puts "   Checking: #{path}"
      gems = Dir.glob(path)
      next unless gems.any?

      $stderr.puts "   Found gems: #{gems.join(', ')}"
      parallel_gems = gems
      break
    end
    parallel_gems
  end

  def validate_project!
    raise "No Gemfile found at: #{@gemfile_path}" unless File.exist?(@gemfile_path)
    raise "No Gemfile.lock found at: #{@gemfile_lock_path}" unless File.exist?(@gemfile_lock_path)

    log_output "‚úÖ Project validation passed"
  end

  def read_dependency_files
    files = []

    # Read Gemfile (using relative paths for Dependabot)
    gemfile_content = File.read(@gemfile_path)
    files << Dependabot::DependencyFile.new(
      name: "Gemfile",
      content: gemfile_content,
      directory: "."
    )

    # Read Gemfile.lock (using relative paths for Dependabot)
    gemfile_lock_content = File.read(@gemfile_lock_path)
    files << Dependabot::DependencyFile.new(
      name: "Gemfile.lock",
      content: gemfile_lock_content,
      directory: "."
    )

    # Look for other dependency files (using relative paths for Dependabot)
    Dir.glob(File.join(@project_path, "**/*.{gemspec,ruby}")).each do |file_path|
      # Remove the project path and any leading slash to get a clean relative path
      relative_path = file_path.sub(@project_path, "").sub(/^\//, "")
      content = File.read(file_path)
      files << Dependabot::DependencyFile.new(
        name: relative_path,
        content: content,
        directory: relative_path.empty? ? "." : File.dirname(relative_path)
      )
    end

    files
  end

  def create_parser(dependency_files)
    source = Dependabot::Source.new(
      provider: "github", # Use a valid provider
      repo: "local-project",
      directory: ".",
      branch: "main"
    )

    # Change to the project directory so Dependabot can find the Git repository
    @original_working_dir = Dir.pwd
    Dir.chdir(@project_path)

    Dependabot::Bundler::FileParser.new(
      dependency_files: dependency_files,
      source: source,
      credentials: [],
      repo_contents_path: @project_path # Use the writable project directory
    )
  end

  def check_security_vulnerabilities_detailed(dependencies, dependency_files)
    log_output "\nüîí Checking for security vulnerabilities with detailed information..."
    log_output "=" * 60

    # This would integrate with security advisory databases
    # For now, fall back to security-only mode
    security_checker = SecurityVulnerabilityChecker.new(@project_path, @options)
    security_checker.check_vulnerabilities(dependencies, dependency_files)

    log_output "\nüìù Note: Detailed security information requires integration with security advisory databases"
    log_output "   Consider using GitHub Security Advisories or Ruby Advisory Database for CVE details"
  end

  def check_all_updates(dependencies, dependency_files)
    log_output "\nüîç Checking for all available updates..."
    log_output "=" * 60

    top_level_deps = dependencies.select(&:top_level?)
    updatable_deps = []

    process_dependencies_for_updates(top_level_deps, updatable_deps, dependency_files)

    if @options[:output_format] == :json
      display_all_updates_json_results(updatable_deps, top_level_deps)
    else
      log_output "\n" + ("=" * 60)
      log_output "üéØ Scan complete! Found #{updatable_deps.length} dependencies with updates " \
           "out of #{top_level_deps.length} total"
    end
  end

  def process_dependencies_for_updates(top_level_deps, updatable_deps, dependency_files)
    top_level_deps.each do |dependency|
      process_single_dependency_for_updates(dependency, updatable_deps, dependency_files)
    rescue StandardError => e
      log_output "   ‚ùå Error checking #{dependency.name}: #{e.message}"
    end
  end

  def process_single_dependency_for_updates(dependency, updatable_deps, dependency_files)
    checker = create_update_checker(dependency, dependency_files)

    if checker.up_to_date?
      log_output "   ‚úÖ #{dependency.name} (#{dependency.version}) - Up to date"
    else
      add_updatable_dependency(dependency, checker, updatable_deps)
      display_update_information(dependency, checker)
    end
  end

  def add_updatable_dependency(dependency, checker, updatable_deps)
    latest_version = checker.latest_version
    latest_resolvable_version = checker.latest_resolvable_version

    updatable_deps << {
      dependency: dependency,
      checker: checker,
      latest_version: latest_version,
      latest_resolvable_version: latest_resolvable_version
    }
  end

  def display_update_information(dependency, checker)
    if @options[:output_format] == :summary
      log_output "   üîÑ #{dependency.name} (#{dependency.version}) ‚Üí #{checker.latest_resolvable_version}"
    else
      display_detailed_update_information(dependency, checker)
    end
  end

  def display_detailed_update_information(dependency, checker)
    log_output "\nüì¶ #{dependency.name} (#{dependency.version})"
    log_output "   üîÑ Update available:"
    log_output "      Latest version: #{checker.latest_version}"
    log_output "      Latest resolvable_version: #{checker.latest_resolvable_version}"
    log_output "      Update strategy: #{checker.update_strategy}"
    log_output "      Requirements to unlock: #{checker.requirements_to_unlock}"

    return unless @options[:show_details]

    log_output "      Current requirements: #{dependency.requirements.map { |r| r[:requirement] }.join(', ')}"
    log_output "      Groups: #{dependency.requirements.map { |r| r[:groups].join(', ') }.join(', ')}"
  end

  def cleanup_temp_directory
    # Restore original working directory
    Dir.chdir(@original_working_dir) if @original_working_dir

    # Clean up the temporary project directory
    if @temp_project_dir && Dir.exist?(@temp_project_dir)
      begin
        FileUtils.rm_rf(@temp_project_dir)
        $stderr.puts "üßπ Cleaned up temporary project directory"
      rescue StandardError => e
        $stderr.puts "‚ö†Ô∏è  Warning: Could not clean up temporary project directory: #{e.message}"
      end
    end
  end

  def create_update_checker(dependency, dependency_files)
    Dependabot::Bundler::UpdateChecker.new(
      dependency: dependency,
      dependency_files: dependency_files,
      credentials: [],
      repo_contents_path: @project_path
    )
  end

  def run_bundle_audit
    log_output "\nüîí Running bundle audit to check for actual security vulnerabilities..."
    log_output "=" * 60

    # Ensure bundler is installed and available
    unless system("bundle --version")
      log_output "‚ö†Ô∏è  bundler not found. Please ensure bundler is installed and in your PATH."
      log_output "   Run 'gem install bundler' if needed."
      exit 1
    end

    # Run bundle audit
    log_output "   Running 'bundle audit' in #{@project_path}..."
    if system("cd #{@project_path} && bundle audit")
      log_output "‚úÖ bundle audit completed successfully!"
      log_output "   Please review the output for actual security vulnerabilities."
    else
      log_output "‚ùå bundle audit failed. Please check the output for details."
      exit 1
    end
  end
end

# Define helper methods for option parsing (must be defined before use)
def add_scan_mode_options(opts, options)
  opts.on("--all-updates", "Show all available updates (not just security)") do
    options[:mode] = :all_updates
  end

  opts.on("--security-details", "Show security vulnerabilities with detailed information") do
    options[:mode] = :security_details
  end
end

def add_output_options(opts, options)
  opts.on("--show-details", "Show detailed update information (default: enabled)") do
    options[:show_details] = true
  end

  opts.on("--no-details", "Hide detailed update information") do
    options[:show_details] = false
  end

  opts.on("--output-format FORMAT", %i(text json summary),
          "Output format: text, json, or summary (default: summary)") do |format|
    options[:output_format] = format
  end
end

def add_bundle_audit_option(opts, options)
  opts.on("--bundle-audit", "Run bundle audit to check for actual security vulnerabilities") do
    options[:bundle_audit] = true
  end
end

def add_help_option(opts, options)
  opts.on("-h", "--help", "Show this help message") do
    display_help_message(opts, options)
  end
end

def display_help_message(opts, options)
  puts opts
  puts "\nScan Modes (default: security-only):"
  puts "  --security-only      Only show dependencies with security vulnerabilities (default)"
  puts "  --security-details   Show security vulnerabilities with detailed information"
  puts "  --all-updates        Show all available updates (not just security)"
  puts "  --bundle-audit       Run bundle audit to check for actual security vulnerabilities"
  puts "\nOutput Options (default: summary):"
  puts "  --show-details       Show detailed update information (default: enabled)"
  puts "  --no-details         Hide detailed update information"
  puts "  --output-format      Choose output format: text, json, or summary (default: summary)"
  puts "\nExamples:"
  puts "  ruby local_scan.rb /path/to/project                    # Security-only, summary output (default)"
  puts "  ruby local_scan.rb --all-updates /path/to/project      # All updates, summary output"
  puts "  ruby local_scan.rb --show-details /path/to/project     # Security-only, detailed summary"
  puts "  ruby local_scan.rb --output-format json /path/to/project # Security-only, JSON output"
  puts "  ruby local_scan.rb --all-updates --output-format text /path/to/project # All updates, text output"
  puts "  ruby local_scan.rb --bundle-audit /path/to/project    # Run bundle audit"
  exit
end

# Command line interface
if __FILE__ == $0
  options = {
    mode: :security_only, # Default mode: security vulnerabilities only
    show_details: true, # Default: show detailed version information
    output_format: :summary, # Default output: summary format
    bundle_audit: false # New option for bundle audit
  }

  OptionParser.new do |opts|
    opts.banner = "Usage: ruby local_scan.rb [OPTIONS] PROJECT_PATH"

    add_scan_mode_options(opts, options)
    add_output_options(opts, options)
    add_bundle_audit_option(opts, options)
    add_help_option(opts, options)
  end.parse!

  if ARGV.empty?
    puts "Error: Please provide a project path"
    puts "Usage: ruby local_scan.rb [OPTIONS] PROJECT_PATH"
    puts "Default: Security vulnerabilities only with summary output"
    puts "Run with --help for more options"
    exit 1
  end

  project_path = ARGV[0]

  begin
    scanner = LocalDependabotScanner.new(project_path, options)
    scanner.scan
  rescue StandardError => e
    puts "‚ùå Error: #{e.message}"
    puts e.backtrace.first(5).join("\n")
    exit 1
  end
end
